* **堆**：对象和数组分配内存，是垃圾收集器管理的主要区域，又称为GC堆，1.7之后运行时常量池也在此。

* **方法区/元空间/直接内存**：储存已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码数据

  **线程独有**

  * **程序计数器**：保存下条指令、分支，循环，跳转、异常处理，线程恢复的位置，唯一不会OOM
  * **虚拟机栈**：一个个栈帧，保存局部变量，操作数栈，动态链接，方法出入口信息
  * **本地方法栈**：执行native方法

  > 运行时常量池：放class编译信息。
  >
  > 字符串常量池：7之前放方法区，之后放堆。

**垃圾回收**：

基本采用分代垃圾回收算法，粗分为新生代和老年代，细分为eden，from survivor, to survivor,老年区

**堆内存常见分配策略**：对象优先在eden区分配，大对象直接进入老年代，长期存活的对象将进入老年代。

**Minor GC**：新生代垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。

**FULL GC/Major GC**: 发生在老年代的GC，速度比Minor GC慢10倍以上。

**判断对象死亡**：引用计数法, 可达性分析法（GC ROOT，找出一些root节点然后构造树，需要两次成为不可达对象，才面临回收，GCROOT对象：虚拟机栈中引用的对象、方法区类静态属性引用的对象-方法区常量池引用的对象、本地方法栈JNI引用的对象。一般被标记两次才会真正被回收）

**无用的类**：所有实例被回收，加载该类的classLoader已被回收，对应的java.lang.class没有在任何地方被引用。

**分代收集**：新生代使用复制算法，老年代使用标记-清除或标记整理。

> 新生代收集器：Serial（串行，复制算法）、ParNew（并行，复制算法）、Parallel Scavenge(注重吞吐量，并行，复制算法)；
>
> 老年代收集器：Serial Old（串行，标记整理）、Parallel Old（并行，标记整理）、CMS（并发，标记清除）；
>
> 整堆收集器：G1（并发、标记整理+复制）；
>
> CMS收集器**：Concurrent mark Sweep（并发标记清除） ,一种以获取最短回收停顿时间为目标的收集器，基本实现垃圾回收和用户线程同时工作。
>
> 1. 初始标记：暂停其他所有线程，记录直接和root相连的对象，需要Stop The World（STW）。
> 2. 并发标记：同时开启GC和用户线程，记录可达对象（不能保证包含当前所有可达对象，因为还在更新）
> 3. 重新标记：暂停用户线程，修正并发标记期间产生变动的那一部分标记记录，需要Stop The World（STW）。
> 4. 并发清除：开启用户线程，同时GC线程开始对标记的区域做清扫。
>
> 缺点及办法：
>
> 1. 垃圾碎片，因为使用的是标记-清除算法，可以设置发生指定次数full gc后对内存做一次压缩。
> 2. 重新标记阶段耗时较久，在full gc之前做一次minor gc，减少年轻代对老年代的无效引用，加快重新标记的开销。
> 3. concurrent mode failure，minor gc的时候将存活对象放进老年代，但是老年代的空间放不下，可以设置占满了百分比多少就开始gc，建议是80%。
> 4. promotion failed，还是发生了minor gc要放对象到老年代，但是老年代的碎片较多，找不到一段连续区域放下它。
>
> **G1收集器**：Garbage-First 面向服务器的垃圾收集器，主要针对多颗处理器及大容量内存的机器，以高概率满足GC停顿时间的要求，还具备高吞吐量性能特征。使用标记整理、可预测的停顿时间模型。维护一个优先列表，优先回收价值最大的region
>
> 1. 初始标记
> 2. 并发标记
> 3. 最终标记
> 4. 筛选回收

**finalize()**：可达性分析中，分析出对象可以回收，如果类有覆盖这个方法，会放到一个F-Queue中，虚拟机触发一个线程去执行，但不会承诺一直等待它运行完避免死锁从而内存回收系统崩溃，GC对处于F-Queue中的对象进行第二次被标记，这时该对象将会被移除“即将回收”集合，等待回收。

**内存泄露**：对象没有被使用了但是因为某些原因不能被回收。例如：栈中push进去的元素一直没有拿出来使用；HashMap的key改了hascode导致之前的找不回来。

Full GC本身不会先进行Minor GC，我们可以配置-XX:+ScavengeBeforeFullGC（非CMS回收算法）、CMSScavengeBeforeRemark（CMS回收算法）可以，**让Full GC之前先进行一次Minor GC**，因为老年代很多对象都会引用到新生代的对象，先进行一次Minor GC可以提高老年代GC的速度。

**对象创建过程** ：

1. **类加载检查**：虚拟机遇到一个new指令的时候，首先去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过，没有的话，必须执行相应的类加载过程。

2. **分配内存**：类加载过就可以确定所需内存大小，为对象分配内存就是在java堆中划分出来一块确定带下的内存。方式有“指针碰撞"和”空闲列表“，选择哪个方式取决于JAVA堆是否规整，而java堆是否规整又由采用的垃圾收集器是否带有压缩整理功能决定。涉及线程安全（采用CAS+失败重试，TLAB:每个线程预先分配内存，则首先在TLAB分配，大于剩余内存或快用完，就用上面的CAS）

> 指针碰撞：内存规整下，通过一个指针区分已使用和未使用的内存的位置，需要使用时，指针移动划分。
>
> 空闲列表：内存不规整，虚拟机维护一空闲列表，需要多大内存空闲列表又显示有就拿去用，如cms收集器

2. **初始化零值**：内存空间初始化，类字段初始值
3. **设置对象头**:类的元数据信息，对象的哈希码，GC分代年龄
4. **执行init方法**

**对象访问定位方式**

1.使用句柄：堆中划分一块内存作为句柄，引用（变量名）储存的是对象的句柄地址，句柄包含对象实例数据地址指针和类型数据指针地址。对象移动只需要改变句柄的实例数据指针。

2.直接指针：引用储存的时候直接对象的地址，直接对象中包含到对象类型数据的指针和对象实例数据。速度快。

**PermGen space异常**：永久代溢出，一般是加载的class太多超出默认的4m，-XX:PermSize=64M-XX:MaxPermSize=128m，但是在java8之后，这个是元空间（直接内存）了。

**-XX:MaxNewSize**：新生代内存大小，与-Xmn一样，Sun建议占总的JVM内存3/8。

**-XX：NewRatio=4**：年轻代与老年代比例1：4。

**-XX：SurvivorRatio=4**：年轻代的eden和一个survior区的比例1 ： 4。和两个survior比就是2:4。

**-Xss**：设置栈大小。

**JVM垃圾回收器参数**：

| 参数               | 描述                                                       |
| ------------------ | ---------------------------------------------------------- |
| UseSerialGC        | 运行在client模式下的默认值，Serial + Serial Old            |
| UseParNewGC        | ParNew + Serial Old                                        |
| UseConcMarkSweepGC | ParNew + CMS + Serial old（此为CMS出现失败后的后备收集器） |
| UseParallelGC      | 运行在Server模式下，Parallel Scavenge + Serial Old         |
| UseParallelOldGC   | Parallel Scavenge + Parallel Old，jdk8默认                 |

**调优建议**

- ​	(单服务器单应用)最大堆的设置建议在物理内存的1/2 到 2/3 之间。
- ​	survivor和eden的最优比例为1:8。年轻代=eden+2survivor。即-XX:SurvivorRatio=8 
- ​	年轻代和老年代的最优比例为1:2，即-XX:NewRatio=2。

**查看web应用的jvm信息**：1. jps查询java应用基础信息，jinfo -flags PID。2. jmap -heap PID查看分代情况， jmap -histo:live <pid>可迫使JVM进行一次full gc。3. jstat -gcutil pid:查看每个代区域使用的百分比情况。

**OOM怎么排查**：如果JVM配置了-XX:+HeapDumpOnOutOfMemoryError，可以拿到发生OOM的时候，堆里面都有些什么。