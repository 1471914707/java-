**一致性Hash**：简单来说，就是一些节点发布在一个圆上，按顺时针找到第一个节点作为处理节点，会涉及增加节点和减少节点。一开始节点太少的时候，可以通过虚拟节点（即同一个节点A，虚拟节点A1,A2..但都是A处理）。

**分布式事务**：

> 1. 两阶段提交方案/XA方案。意思就是各个数据库都准备好一个有错了全部回滚，但是一般一个服务对应一个库，所以操作上比较难控。（spring+JTA）
> 2. TCC方案（Try Confirm Cancel）：Try阶段对各个服务的资源做检测以及对资源进行锁定或预留。Confirm阶段是在各个服务中执行实际的操作。Cancel如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，就是执行已经执行成功的业务逻辑回滚。实际上是写代码回滚动和补偿。
> 3. 本地消息表：依赖数据库的消息表来管理事务.A、B事务通知，失败又通知..............复杂到不想说
> 4. 可靠消息最终一致性方案：本地消息表改成用MQ，A系统发一个准备消息到mq(发送失败就直接取消操作不执行了)，发送成功后，执行本地事务，如果成功就告诉mq发送确认消息，如果失败就告诉mq回滚动消息，如果发送了确认消息，此时B系统会接收到确认消息，然后执行本地的事务，mq会自动定时论询所有准备消息回调你的接口，问你这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你可以查下数据库看之前本地事务是否执行，如果回滚了，那么也回滚，这个就是避免本地执行成功了而确认消息却发送失败。B失败就回滚，通知A或直接抛错通知人员。
> 5. 最大努力通知：A本地事务执行完，发送个消息到MQ，这里会有个专门消费MQ的最大努力通知服务，这个服务会消费MQ然后写入到数据库记录下来，或者放到个内存队列也可以，接着调用B的接口，B成功就ok，失败了那么最大努力通知服务就定时尝试重新调用系统B，反复N次，最后还是不行就放弃。
> 6. 事件机制：http://www.uml.org.cn/wfw/201705271.asp

