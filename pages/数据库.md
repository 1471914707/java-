# 数据库

**数据类型**：数值、时间、字符串、枚举。

**int（11）**：11还是其他都不会影响int的范围，只是前面填充0到11位。

**删除了数据之后自增主键**：innodb内存中会保留最大id，所以还是会以最大id+1作为主键，但是重启mysql之后内存清了，就会重新计算当前最大id+1。MyISAM则把最大id储存在文件中，重启也还在。

**select count(1)和select count(*)**：实际无区别。表没有主键那么count(1)更快，有主键的话count(主键)最快。count(\*)找表a中最短的列进行统计行数，如果一个表用count(*)比较多，考虑在一个最短的列建立一个单列索引，会极大的提升性能。count(col)不包括NULL字段统计。

**优化方向**：数据库表设计，良好的SQL、分库分表，主从读写分离、缓存、搜索引擎、硬件升级、索引使用、系统配置。

**SQL调优**：

1. 命中查询缓存
2. explain使用索引
3. limit 1
4. 搜索字段走索引
5. join字段走索引（属性相同，字符集相同）
6. 避免使用order by rand()
7. 避免select *，消耗网络传输、需要查数据字典、查不了索引字段需要回表，客户端映射字段多有消耗。
8. select字段最好可以都是组合索引字段，不用查到主索引树去。

第一范式是字段最小不可拆解，第二范式是字段和主键关联依赖，第三范式是字段和主键无间接关联（传递依赖）无冗余。

**索引类型**：普通索引、唯一索引、主键索引、外键索引、组合索引、全文索引。

MVCC 一词代表的是多版本并发控制，只在READ COMMITED和REPEATABLE READ两个隔离级别下工作。

**mysql存储引擎**

1. **MyISAM**：性能极佳，全文索引，压缩。但不支持事务和行级锁，只有表级锁，查询较快，崩溃无法恢复，不支持外键，不支持MVCC。
2. **InnoDB**：支持外键，事务/回滚，行级锁，崩溃可恢复，支持MVCC。

**mysql索引** ：有Hash索引（单个查询）、BTree索引，全文索引（full text)。

1. **MyISAM**：B+Tree树叶节点的data域就是数据记录的地址，在索引检索的时候，先走B+Tree搜索索引，如果指定KEY存在，就取出data域的值，然后根据域值存的地址读取相应的数据记录。非聚簇索引。
2. **InnoDB**：其数据文件本身就是索引文件，相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表索引文件本身就是主索引，这称为聚簇索引。其他索引是辅助索引，叶节点为主键key和索引字段数据。

**数据库事务**

**ACID**：原子性、一致性、隔离性、持久性

**原子性**：要么全部执行成功，要么都不行执行，MVCC记录版本允许回滚。

**一致性**：事务开始和结束之间的中间状态不会被其他事务看到。

**隔离性**：事务不会被其他事务干扰。

**持久性**：每一次事务提交后就会保证不会丢失。

> 导致问题，1.脏读（读到别的事务尚未提交的数据），2.丢失修改（当一个事务修改是，另一个事务也在修改覆盖，导致前面事务修改丢失），3.不可重复读（两次读的数据不一致）,4.幻读（读着的数据行数变化）
>
> **SQL标准定义四个隔离级别**：
>
> 1. READ-UNCOMMITTED（读取未提交）,允许读取尚未提交的数据。导致脏读，幻读，不可重复读
> 2. READ-COMMITTED（读取已提交）,允许读取并发事务已经提交的数据，还会幻读，不可重复读
> 3. REPEATABLE-READ（可重复读）,对同一个字段多次读取结果完全一致除非自己改，还会幻读
> 4. SERIALIZABLE（可串行化），最高隔离级别，完全ACID隔离，一个个事务依次执行
>
> **mysql默认的是可重复读**，使用next-key lock锁算法避免幻读。
>
> InnoDB存储引擎锁算法：record lock（行锁）、Gap lock（间隙锁，锁一个范围，不包括记录本身，这也是被锁对象不存在的时候），Next-key lock（record+gap锁定一个范围，包括记录本身）

**死锁原因**：互斥条件（某一时间独占资源）、请求和保持（已获取的资源不释放）、不可剥夺（已获取的资源，不能强行剥夺）、循环等待。

**降低死锁**：超时释放、顺序访问、避免事务干扰、事务简单、降低隔离级别、资源一次获取否则都释放。